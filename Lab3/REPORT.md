# Отчет по лабораторной работе №3
##  Применение Пролога для решения задач поиска в пространстве состояний.
## по курсу "Логическое программирование"

### студент: Савин А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение
Методы поиска в пространстве состояний осуществляют последовательный просмотр конфигураций или состояний задачи с целью обнаружения целевого состояния, имеющего заданные
характеристики или удовлетворяющего некоторому критерию. Эти задачи могут быть решены с помощью разных видов поиска: поиск в глубину, поиск в ширину и поиск с итерационным заглублением.
Prolog подходит для работы подобными задачами с перебором и может решить их меньше чем за секунду. 

## Задание: 
6. Вдоль доски расположено 8 лунок, в  которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним
пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые - только влево.

## Принцип решения
В программе представлены три вида поиска. Общим для них являются предикаты move и prolong. Move задает способы перемещения шаров внутри лунок. Рассматриваются четыре случая начальных
состояний и действия, которые должна произвести программа при встрече с ними. С помощью append мы заменяем 3 знака в списке, на другие 3 знака, тем самым производя перестановку.
prolong - проверка во избежание зацикливаний. Далее идут функции, отвечающие непосредственно за поиск.
dpth и search_dpth осуществляют поиск в глубину. dpth выполняет продвижение вглубь по "дереву" посредством заданных ранее шагов (move), через функцию prolong.
В случае, если мы перебрали все вершины, то  есть текущая вершина совпадает с конечной, выходим из функции. search_dpth вызывает все функции необходимые для работы поиска. 
Также здесь запускается таймер, для измерения времени работы программы. 
bdth и search_bdth обеспечивают работу поиска в ширину. В bdth сначала проходит поиск всех возможных шагов, которые можно сделать из текущего состояния, после чего эти пути заносятся
в общий список. search_bdth запускает рекурсию и рассчитывает время, которое затратил поиск.
Для поиска с итерационным заглублением необходим предикат int, который генерирует максимальную глубину поиска. В id происходит сам поиск, похожий на поиск в глубину, но здесь учитывается
уровень, на который "погружается" рекурсия. На него также можно поставить ограничение, чтобы избежать переполнений. search_id измеряет время работы и вызывает рекурсию. Здесь можно 
организовать само ограничение по итерациям в зависимости от максимальной глубины поиска, полученной в int.

## Реализация:
```prolog
move(A,B):- append(Start,[b,e|End],A), append(Start,[e,b|End],B).
move(A,B):- append(Start,[e,w|End],A), append(Start,[w,e|End],B).
move(A,B):- append(Start,[b,w,e|End],A), append(Start,[e,w,b|End],B).
move(A,B):- append(Start,[e,b,w|End],A), append(Start,[w,b,e|End],B).

prolong([X|T],[Y,X|T]):- move(X,Y), not(member(Y,[X|T])).

dpth([X|T],X,[X|T]).
dpth(P,F,L):-
	prolong(P,N),
	dpth(N,F,L).

search_dpth(Start,Finish,Delta1) :-
	get_time(Ts),
	dpth([Start],Finish,Path),
	get_time(Te),
    Delta1 is Te - Ts,!.
%%%%
bdth([[X|T]|_],X,[X|T]).
bdth([P|QI],X,R):-
	findall(Z,prolong(P,Z),T),
	append(QI,T,QO),
	bdth(QO,X,R).

search_bdth(Start,Finish,Delta2) :-
    get_time(Ts),
    bdth([[Start]],Finish,Path),
    get_time(Te),
    Delta2 is Te - Ts,!.
%%%%
int(1).
int(N):-int(M),N is M+1.

id([X|T],X,[X|T],0).
id(P,X,L,N):-
    prolong(P,Z),
    N1 is N-1,
    id(Z,X,L,N1).

search_id(Start,Finish,Delta3):-
    get_time(Ts),
    int(Level),
    id([Start],Finish,Path,Level),
    get_time(Te),
    Delta3 is Te - Ts.
%%%%%%%%%%%%%%%
comparesearch(Start,Final) :-
    search_dpth(Start,Final,D1),
    write('DEPTH SEARCH TAKES '), write(D1), nl,
    search_bdth(Start,Final,D2),
    write('BREADTH SEARCH TAKES '), write(D2), nl,
    search_id(Start,Final,D3),
    write('ID SEARCH TAKES '), write(D3), nl.

?-comparesearch([b,b,b,b,e,w,w,w],[w,w,w,e,b,b,b,b]).
```
Результаты замеров следующие: 
Result#1
DEPTH SEARCH TAKES 0.0009720325469970703
BREADTH SEARCH TAKES 0.0019958019256591797
ID SEARCH TAKES 0.014985084533691406
Result#2
DEPTH SEARCH TAKES 0.0009658336639404297
BREADTH SEARCH TAKES 0.0019989013671875
ID SEARCH TAKES 0.016952991485595703

Как видно из замеров, самым эффективным по времени являются поиска в глубину, но он ищет всего один путь, причем любой, длины. Проходя дерево всех возможностей максимально глубоко,
возвращаясь назад при неудаче. Поиск в ширину же составляет список всех возможных решений проблемы. Однако при поиске в ширину приходится использовать бОльшее количество памяти. 
При итерационном заглублении перебираются все возможные глубины пока на ней не найдется путь, который и является кратчайшим. 

## Выводы
Выполняя лабораторную работу номер 3, я больше узнал о способах поиска кратчайших путей в задачах. Выбор поиска зависит от требований по решению задачи и доступным ресурсам, как по
памяти, так и по времени. К примеру, поиск в глубину подойдет, если нам надо найти быстро любой путь. Для решения поставленной задачи подошел поиск в глубину, так как он находит
решение за кратчайшее время. Время на работу может меняться в зависимости от последовательности входных данных при работе с графами. Все алгоритмы защищены от зацикливаний с помощью
условий в prolong. Проблема может возникнуть у итерационного заглубления, но она решается с помощью регулируемых ограничений. 




