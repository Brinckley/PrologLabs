# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Савин А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение
В языке Prolog списки (List) являются рекурсивными структурами. Представить визуально их можно в виде бинарного дерева, где из каждой вершины выходит две ссылки: на элемент, находящийся
наверху в данный момент (Голову) и на Хвост, который представляет собой остальную часть списка. Взаимодействие со списком и его прочтение происходит посредством рекурсивного обхода. 
Как и в императивных языках в Prolog существует множество функций по взаимодействию со списками (append, remove) и получению информации о них (length, member). Также сходством является
возможность менять количество элементов в списке. Представление данных в виде дерева также используется в структуре map, которая является ассоциативным контейнером.

## Задание 1.1: Предикат обработки списка
Написать собственную реализацию стандартных предикатов по работе со списками. 

Предикат length возвращает длину списка. Получает ее он путем пересчета всех элементов, пробегая снизу вверх по списку.
Предикат member проверяет существует ли заданный элемент внутри списка. Во время проверки предикат сравнивает значение полученного элемента с каждым элементом в списке, пока
не найдется совпадение или не кончится список. В первом случае возвращается значение Yes, а во втором - No.
append - функция по конкатенации двух списков в третий. Предикат получает на вход два списка, затем проходится по первому списку, по окончанию которого записывает второй список в результат,
после чего поэлементно приписывает первый список к результату.
remove, как ясно из названия удаляет заданный элемент из списка.
Предикат permute по-разному переставляет элементы между двумя списками.
sublist выполняет поиск подстроки в строке.
writelist выводит на экран список.

Примеры использования:
?-length(['a','b','c','d','t'],R), write(R).
?-member([1,2,3,4,5,6], 2).
?-append(R, ['a','b','c'],['d','t']).

Реализация:
length([], 0).
length([_|Y], N) :- length(Y, N1), N is N1 + 1.

member(A, [A|_]).
member(A, [_|Z]) :- member(A, Z).

append([], X, X).
append([A|X], Y, [A|Z]) :- append(X,Y,Z).

remove(X, [X|T], T).
remove(X, [Y|T],[Y|T1]) :- remove(X,T,T1).

permute([],[]).
permute(L,[X|T]) :- remove(X,L,R),permute(R,T).

sublist([],T).
sublist([X|S], T) :- member(X,T),sublist(S,T).

writelist([]).
writelist([X|L]) :- write(X), nl, writelist(L).
## Задание 1.2: Предикат обработки числового списка
Задание: 2. Удаление последнего элемента
deletelast - предикат, удаляющий последний элемент списка. Удаление происходит за счет просмотра списка, и перемещения элементов в результирующий список, но на последней итерации, 
когда просматривается последний элемент, этот элемент не копируется в результат. Таким образом, получаем список идентичный изначальному, но без последнего элемента.

%With standard
sdeletelast(L, R) :- append(R,[X], L).
%Without standard
deletelast([_],[]).
deletelast([X|T],[X|Tnew]) :- deletelast(T, Tnew).

%?-deletelast([a,b,c,d],T),write(T).
%?-sdeletelast([a,b,c,d],T),write(T).

Задание: 6. Вычисление числа четных элементов
Идея программы заключается в подсчете количества чисел, удовлетворяющих предикату checkeven. Внутри checkeven происходит проверка четности числа за счет рекурсивного вычитания двойки
из числа. Этим способом вычисляется остаток от делении на 2. Соответственно, за каждое число прошедшее проверку прибавляется 1 к счетчику, в противном случае прибавляем 0.

Counteven([], 0).
counteven([X|T], N) :- counteven(T, N1), checkeven(X, 0, R), N is N1 + R.

checkeven(1, S, S).
checkeven(0, S, N) :- N is S + 1.
checkeven(X, S, N) :- X1 is X - 2, checkeven(X1, S, N).

?-counteven([2,2,2,4,5,6,2,0,0,0], N), write(N).

## Задание 2: Реляционное представление данных
Файл: one.pl
Задание: 
Вариант 2
 - Напечатать средний балл для каждого предмета
 - Для каждой группы, найти количество не сдавших студентов
 - Найти количество не сдавших студентов для каждого из предметов

Для первого задания понадобиться общая сумма всех оценка. Она находится в предикате sum, который рекурсивно находит сумму всех оценок. Еще необходимо знать количество всех оценок. 
Это находится обычным предикатом length, так как все оценки уже подаются в списке. Главные операции происходят в предикате averagemark. Здесь составляется список по заданным условиям.
В условие входит предмет. С помощью bagof составляется список всех оценок по заданному предмету, а затем, после вычисления общей суммы и длины, путем деления получаем среднюю оценку.

sum([],0).
sum([X|T],N) :- sum(T, N1), N is N1 + X.

length_([],0).
length_([X|T], N) :- length_(T, N1), N is N1 + 1.

averagemark(Subject,Res) :- bagof(Mark, grade(_,Subject,Mark), R), sum(R, RS), length_(R, RL), Res is RS / RL.

Для второго задания с помощью findall создаем список всех студентов заданной группы, после чего отправляем его в предикат notpassed. В предикате notpassed просматриваем каждого
студента группы через рекурсию. Для каждого студента выполняем следующее: смотрим все оценки студента и подсчитываем количество двоек. В предикате amountreturner проверяем чему 
равен счетчик. Если он не ноль, что мы возвращаем один, если да, то ноль. Затем добавляем результат к общему счетчику. Это сделано для того, чтобы студенты, которые не сдали более 
одного предмета считались как один студент. 

search(Student, Res) :- findall(Student, grade(Student, _, 2), List), length_(List, Res).

amountreturner(0, 0).
amountreturner(_, 1).

notpassed([], 0).
notpassed([Student|T], Res) :- notpassed(T, Res1), search(Student, Amount), amountreturner(Amount, Res0), Res is Res0 + Res1.

students(Group, Res) :- findall(NotPassed, student(Group, NotPassed), List), notpassed(List, Res).

Для третьего пункта сначала расшифровываем аббревиатуру предмета и для нее ищем количество несдавших студентов через findall. После чего получаем длину списка студентов и возвращаем результат.
notsubpas(Subject, Res) :- subject(ASubject, Subject), findall(Student, grade(Student, ASubject, 2), List), length(List, Res).

Пример вызова функций:

?-averagemark('PSY',AVG),write(AVG).
?-students(103, Res), write(Res).
?-notsubpas('Математический анализ', Res), write(Res).

Недостатки реляционного представления заключаются в том, что требуется слишком много отдельных пар, к примеру, студент-оценка или предмет-аббревиатура, это усложняет обращение к данным. 
Хотя при более простых обращениях, нам не требуется тащить ненужную информацию. Конкретное представление имеет ряд преимуществ. Можно хранить данные, принадлежащие одному объекту (студенту)
в одной ячейке, и при необходимости обращаться к ней напрямую, а не просматривать большой список данных.  

## Выводы
Лабораторная работа номер 1 познакомила меня с логическим программированием через язык prolog. Реализация программ показалась чем-то похожей на машину Тьюринга и алгоритмы Маркова.
Заставила задуматься над реализацией простых функций через рекурсивное представление. Научила выполнять сложные запросы к набору данных через составление списков по более простым критериям.
Также Prolog меняет общее устоявшееся понимание программирования за счет кардинальной смены стиля реализации знакомых функций. Для обучения подобный подход хорошо подходит. 




