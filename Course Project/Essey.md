Логические языки как путь к автоматическому решению задач компьютером
=====================================================================

Вступление
----------
На протяжении многих веков исследования в различных областях все усложнялись, а вместе с ними становились труднее вычисления и прочие операции, производимые с результатами 
экспериментов или наблюдений. Сопоставление небольших объемов данных может быть легко осуществлено одним ученым или небольшой группой, но что делать, если вариантов перестановок полученных 
значений много больше, чем можно обработать самостоятельно, к тому же чаще всего приходится удерживать в голове множество разных факторов. В таких случаях гораздо проще запрограммировать
условие отбора данных, тем самым заметно упростив задачу. Логическое программирование есть лишь одна из парадигм, но подходит для обработки данных и решения задач по дискретной 
математике лучше всего. 

Языки логичкского программирования
----------------------------------

Основным языком логического программирования изначально был Planner. Его создатель Карл Хьют предполагал, что подобный язык может служить способом создания команд для работы 
искусственного интеллекта. Хоть использовать Planner в полную силу не удалось, но тенденции в развитии языков для робототехники были заложены, также этот язык стал прородителем всех
логических языков программирования. Структура языка Prolog, созданного в 1972 году Аленом Колмероэ, основывается на предикатах математической логики дизъюнктов Хорна.
По сути, язык пресдставляет собой совокупность предикатов, которые проверяют истинность некоторых утверждений. Подобная структура необычна и сильно отличается от более привычных языков,
но является куда более близкой к языку математической логики чем остальные.  

Примеры решения задач на Prolog
-------------------------------

В первую очередь Prolog ассоциируется с решением задач по комбинаторике. С помощью логического программирования эти задачи решаются довольно. 
Сначала требуется аккуратно сформулировать некоторые суждения, а потом преобразовать их в общее большое условие через которое и будут прогоняться все возможные перестановки. 
Такими задачами могут быть всем известные задачи про "рыцарей и лжецов" или про "волка, козу и капусту".
Рассмотрим пример кода для лабороторной работы номер 2:
```prolog
logicalnot("Чук", "Гек").
logicalnot("Гек", "Чук").
truth("Чук", 1, false).
truth("Чук", 2, false).
truth("Чук", 3, false).
truth("Чук", 4, true).
truth("Чук", 5, true).
truth("Чук", 6, true).
truth("Чук", 7, true).
truth("Гек", 1, true).
truth("Гек", 2, false).
truth("Гек", 3, true).
truth("Гек", 4, false).
truth("Гек", 5, true).
truth("Гек", 6, false).
truth("Гек", 7, true).

pair(7, 1).
pair(N, N + 1).
sayname(Person, true) :- Person = "Чук".
sayname(Person, false) :- not(Person = "Чук").
sayyesterday(Today, Yesterday, true) :- pair(Yesterday, Today).
sayyesterday(Today, Yesterday, false) :- not(pair(Yesterday, Today)).
saytomorrow(Today, Tomorrow, true) :- pair(Today, Tomorrow).
saytomorrow(Today, Tomorrow, false) :- not(pair(Today, Tomorrow)).
```
Вначале мы задаем некоторые правила на которые будем опираться позже. Это дни недели, когда Чук и Гек говорят правду или ложь. Они записываются с помощью обычных предикатов, принимающих
имя, номер дня недели и true/false которые отвечают за то, говорит ли человек правду в этот день недели. Подобные предикаты практически полностью копируют человеческий язык. 
Для осуществления процесса перебора используются вспомогательные предикаты logicalnot и pair. Затем практически полностью мы переносим фразу из условия на логический язык программирования,
тем самым превращая условие задачи в очередной набор предикатов, но в этот раз чуть более сложных.
```
solve :- truth(Sp1, Today, Res1), logicalnot(Sp1, Sp2), truth(Sp2, Today, Res2),
         sayname(Sp1, Res1), sayyesterday(Today, 7, Res1), saytomorrow(Today, 5, Res2), truth(Sp2, 3, Res2),!.

```
solve явлеятся итоговым предикатом, который отображает совокупность всех утверждений в одно и выводит ответ, после того, как сработал полный перебор всех возможных вариантов сочитаний.
Таким образом, задача была полностью автоматизирована и превращена в набор утверждений с которыми машина справится быстрее человека.

Видов задач на комбинаторику чрезвычайно много, существуют и множество способов их решения. Одним из самых интересных является поиск в глубину.
Здесь, как и в каждой задаче на Prolog необходимо задать все возможные операции с объектами из задачи. 
Покажем применения на примере задачи о перемещении шаров.
```prolog
move(A,B):- append(Start,[b,e|End],A), append(Start,[e,b|End],B).
move(A,B):- append(Start,[e,w|End],A), append(Start,[w,e|End],B).
move(A,B):- append(Start,[b,w,e|End],A), append(Start,[e,w,b|End],B).
move(A,B):- append(Start,[e,b,w|End],A), append(Start,[w,b,e|End],B).

prolong([X|T],[Y,X|T]):- move(X,Y), not(member(Y,[X|T])).
```
Предикаты move задают законы по которым могут двигаться шары внутри лунок. "Перепрыгивание" белого шара через черный и наоборот. "Шаги" влево для белых и вправо для черных.
Затем организовываем само описание движения, которое будет использоваться при переборе.  
```prolog
dpth([X|T],X,[X|T]).
dpth(P,F,L):-
	prolong(P,N),
	dpth(N,F,L).
```
В предикате dpth Реализуется сам поиск в глубину путем перебора всех возможных шагов в данный момент и продвижения дальше по рекурсии.

Помимо автоматического решения задач на комбинаторику, Prolog может быть использован и для автоматизации поиска объектов в списке. Начнем с того, что практически весь необходимый 
инструментарий для работы со списком объектов может быть реализован рекурсивно. Как пример возьмем функции вычисления длины списка и проверки наличия элемента в нем. 
```prolog
Length([], 0).
length([_|Y], N) :- length(Y, N1), N is N1 + 1.

member(A, [A|_]).
member(A, [_|Z]) :- member(A, Z).
```
Как и всякая рекурсивная функция, length имеет условие завершения. Обычно это условие пишется вверху и представляет собой набор значений, который свидетельствует о том, что все элементы
уже перебрали или программа достигла нужного результата. В данном случае рекурсия заканчивает свое "погружение", когда в списке не осталось ни одного элемента. Тогда условный счетчик
получает базовое значение ноль, к которому в последствии прибавляется единица за каждый эелемент списка, когда программа идет обратно по рекурсии. 

Наличие возможности создать список данных уже заметно расширяет обласит применения языка Prolog. Например, можно найти число четных числе во входном наборе. 
```prolog
Counteven([], 0).
counteven([X|T], N) :- counteven(T, N1), checkeven(X, 0, R), N is N1 + R.

checkeven(1, S, S).
checkeven(0, S, N) :- N is S + 1.
checkeven(X, S, N) :- X1 is X - 2, checkeven(X1, S, N).
```
На этом примере мы видим, что на каждой итерации рекурсии производится целый набор действий: сложение и вызов функции проверки числа на четность. Возможно, для подобных задач существуют 
другие более лекгие и быстрые способы, но в логическом программировании такое тоже возможно, причем не самым привычным способом. 

Вывод
-----
К сожалению, сейчас язык Prolog не слишком востребован, но все еще используется, к тому же он может стать базой для развития других языков. Простота с которой возможно описывать задачи 
дискретной математики несомненно привлекает и привлечет новых пользователь, к тому же, порог входа в таких случаях довольно низкий. Возможность решать задачи с использованием
списков, хоть и не является главным преимуществом языка, но становится дополнением способным облегчить решение многих задач, в том числе и по комбинаторике.